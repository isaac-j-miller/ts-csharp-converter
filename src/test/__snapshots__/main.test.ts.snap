// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`snapshot works 1`] = `
"public namespace TestNamespace {
    using System;
    using System.Collections.Generic;
    public enum TestEnum1 {
        FooBar,
        Baz,
        Fooooo
    }
    public enum TestEnum2 {
        Value1 = 100,
        Value2,
        Value3
    }
    public static class GlobalVars {
        public const int[] UsingRef = {  };
        // Unable to resolve value for type
        public const string FRef = null;
        public const string FOO = \\"some string\\";
        public const string BAR = \\"some string as const\\";
        public const int Whatever = 1;
        /**
        * an array of strings
        */
        public const string[] AStringArray = { \\"foo\\", \\"var\\", \\"aaaa\\" };
        public const int[] ANumberArray = { 1, 2, 3, 4 };
        // a 2D int array
        public const int[,] A2dArray = { { 1, 2, 3 }, { 2, 3, 4 }, { 4, 5, 6 } };
    }
    public class Foo {
        // x is a number
        public int X { get; set; }
        // comment comment comment
        public string Y { get; set; }
    }
    public enum Abc {
        A,
        B,
        C
    }
    public class GenericWithConstraints<T> where T: string {
        public T Str { get; set; }
    }
    public class GenericWithConstraints2<T> where T: Foo {
        public T Foo { get; set; }
    }
    public class GenericWithConstraints3<T> where T: int {
        public T Digit { get; set; }
    }
    public class GenericWithConstraints4<T> where T: object {
        public T Z { get; set; }
    }
    public class SomeGenericType<T> {
        public T Foo { get; set; }
        public Abc Bar { get; set; }
    }
    public class DefaultGeneric<Ta> {
        public Ta V { get; set; }
    }
    internal class SomeLargerTypexClass<U> {
        public U Foo { get; set; }
    }
    public class SomeLargerType<U> {
        public string A { get; set; }
        public Abc Y { get; set; }
        public int V { get; set; }
        public SomeLargerTypexClass<U> X { get; set; }
    }
    public class Composite {
        public int V { get; set; }
        public Abc Foo { get; set; }
        public Abc Bar { get; set; }
        // x is a number
        public int X { get; set; }
        // comment comment comment
        public string Y { get; set; }
    }
    internal class BlahBlahxClass {
        // x is a number
        public int X { get; set; }
        // comment comment comment
        public string Y { get; set; }
        public string Foo { get; set; }
        public Abc Bar { get; set; }
    }
    public class BlahBlah {
        public BlahBlahxClass[] X { get; set; }
        public SomeLargerType<DefaultGeneric<int>>[] Y { get; set; }
    }
    public class ZZZ {
        public string Z { get; set; }
        public System.Collections.Generic.Dictionary<string, string> V { get; set; }
        public System.Collections.Generic.Dictionary<string, DefaultGeneric<int>> Y { get; set; }
        public System.Collections.Generic.Dictionary<string, SomeGenericType<Abc>> X { get; set; }
    }
    public class Bs<T> : System.Collections.Generic.Dictionary<string, DefaultGeneric<T>> { }
    public enum SomeStupidSubEnum {
        FooBar,
        Baz
    }
    public enum SomeStupidSubEnum2 {
        Fooooo = 2,
        Value2 = 101
    }
    public class DumbType {
        public double Num { get; set; }
        public int Dumber { get; set; }
        public string Un { get; set; }
        public object Absurd { get; set; }
    }
    internal class IndexTypeaClass {
        public Abc Foo { get; set; }
    }
    public class IndexType {
        public System.Collections.Generic.Dictionary<string, string> Abc { get; set; }
        public IndexTypeaClass A { get; set; }
    }
    public class GenericIndexType<T> where T: System.Collections.Generic.Dictionary<object, T> {
        public IndexType I { get; set; }
        public T V { get; set; }
    }
    public class AnotherType {
        public string[,,] X { get; set; }
        public int[,,,,] N { get; set; }
    }
    public class GenericArrayType {
        public SomeGenericType<Composite>[] J { get; set; }
        public AnotherType[,] K { get; set; }
    }
    public class GenericArrayType2<V> {
        public V[,] SomeProperty { get; set; }
        public DefaultGeneric<V>[] AnotherProperty { get; set; }
    }
    public class NumbersWithJsDoc {
        /**
        * @type {int}
        */
        public int IntProperty { get; set; }
        /**
        * @type {float}
        */
        public double FloatProperty { get; set; }
    }
    public class ConsumesInterface {
        public int Integer { get; set; }
        public int Float { get; set; }
    }
    public enum TestEnum3 {
        X,
        Y,
        Z
    }
    public class UnionIndex {
        public int? A { get; set; }
        public int? B { get; set; }
        public int? C { get; set; }
    }
    public class UnionIndex2 {
        public bool A { get; set; }
        public bool B { get; set; }
        public bool C { get; set; }
    }
    public class GenericUnionIndex<T, V> where T: object : System.Collections.Generic.Dictionary<T, V> { }
    public class GenericUnionIndex2<T> where T: object : System.Collections.Generic.Dictionary<T, string> { }
    public class GenericUnionIndex3<T> where T: object : System.Collections.Generic.Dictionary<T, object> { }
    public class GenericUnionIndex4<T> where T: object : System.Collections.Generic.Dictionary<T, object> { }
    public class GenericConsumer : System.Collections.Generic.Dictionary<string, int> { }
    // this is a comment that should show up on the GenericConsumerConsumer class
    public class GenericConsumerConsumer {
        // g comment
        public GenericConsumer G { get; set; }
    }
    public class FooBar {
        // This property is a function, and it was unable to be translated at this time
        public object? F { get; set; }
        // This property is a function, and it was unable to be translated at this time
        public object? G { get; set; }
    }
    public class Whatever1 {
        public object W { get; set; }
    }
    public class RecursiveType {
        public int T { get; set; }
        public RecursiveType R { get; set; }
    }
    public class RecursiveType2 {
        public int T { get; set; }
        public RecursiveType R { get; set; }
    }
    public class RecursiveType3 {
        public int T { get; set; }
        public RecursiveType? R2 { get; set; }
    }
    public class GenericRecursive {
        public SomeGenericType<object> T { get; set; }
    }
    public enum DumbEnum {
        MemberOne,
        MemberTwo,
        Member3,
        MemberMember1,
        PascalMember,
        ApplicationFooooABCX
    }
    public class ATuple : System.Tuple<string, int> { }
    public class BTuple : System.Tuple<double, double, double> { }
    public class CTuple : System.Tuple<string, double, UnionIndex2, object> { }
    public class TupleMap : System.Collections.Generic.Dictionary<string, BTuple> { }
    public class GenericTupleMap<T, U, V> : System.Tuple<T, U, V> { }
    public class GenericTupleMap2<T, V> : System.Tuple<T, V[]> { }
    public class TupleMap2 : System.Tuple<string, string[], int[,,]> { }
    public class TupleMap3 : System.Tuple<ATuple[], BTuple[,]> { }
    public class Tuple1 : System.Tuple<string, double, SomeGenericType<double>, DefaultGeneric<double>, SomeGenericType<Abc>> { }
    public class A {
        public int Foo { get; set; }
    }
    public class B {
        public string Bar { get; set; }
    }
    // Warning: This class might not have been generated correctly. Source to check /Users/imiller/code/personal/csharp-converter/src/test/subfolder/conditional.ts:10
    // Source code:
    // 
    // export type Inverse<T extends A | B> = T extends A ? B : A;
    public class Inverse<T> where T: object { }
    public class ConsumesConditional {
        public B Prop1 { get; set; }
    }
    public class ConditionalMappedType<T, V> where T: string : System.Collections.Generic.Dictionary<string, object> { }
    public class ConsumesConditionalMappedType {
        public System.Collections.Generic.Dictionary<object, A> X { get; set; }
        public System.Collections.Generic.Dictionary<object, B> Y { get; set; }
    }
}"
`;
