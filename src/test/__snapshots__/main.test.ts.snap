// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`snapshot works 1`] = `
"namespace TestNamespace {
    using System;
    using System.Collections.Generic;
    using System.Runtime.Serialization;
    public enum TestEnum1 {
        FooBar,
        Baz,
        Fooooo
    }
    public enum TestEnum2 {
        Value1 = 100,
        Value2,
        Value3
    }
    public static class GlobalVars {
        public readonly static int[] UsingRef = {  };
        #nullable enable
        // Unable to resolve value for type
        public readonly static string? FRef = null;
        #nullable disable
        public readonly static string FOO = \\"some string\\";
        public readonly static string BAR = \\"some string as const\\";
        public readonly static int Whatever = 1;
        /**
        * an array of strings
        */
        public readonly static string[] AStringArray = { \\"foo\\", \\"var\\", \\"aaaa\\" };
        public readonly static int[] ANumberArray = { 1, 2, 3, 4 };
        // a 2D int array
        public readonly static int[,] A2dArray = { { 1, 2, 3 }, { 2, 3, 4 }, { 4, 5, 6 } };
    }
    public class Foo {
        // x is a number
        public int X { get; set; }
        // comment comment comment
        public string Y { get; set; }
    }
    public enum Abc {
        [EnumMember(Value = \\"a\\")]
        A,
        [EnumMember(Value = \\"b\\")]
        B,
        [EnumMember(Value = \\"c\\")]
        C
    }
    public class GenericWithConstraints<T> {
        public T Str { get; set; }
    }
    public class GenericWithConstraints2<T> where T: Foo {
        public T Foo { get; set; }
    }
    public class GenericWithConstraints3<T> {
        public T Digit { get; set; }
    }
    public class GenericWithConstraints4<T> {
        public T Z { get; set; }
    }
    public class SomeGenericType<T> {
        public T Foo { get; set; }
        public Abc Bar { get; set; }
    }
    public class DefaultGeneric<Ta> {
        public Ta V { get; set; }
    }
    public class SomeLargerTypeXClass<U> {
        public U Foo { get; set; }
    }
    public class SomeLargerType<U> {
        public string A { get; set; }
        public Abc Y { get; set; }
        public int V { get; set; }
        public SomeLargerTypeXClass<U> X { get; set; }
    }
    public class Composite {
        public int V { get; set; }
        public Abc Foo { get; set; }
        public Abc Bar { get; set; }
        // x is a number
        public int X { get; set; }
        // comment comment comment
        public string Y { get; set; }
    }
    public class BlahBlahXClass {
        // x is a number
        public int X { get; set; }
        // comment comment comment
        public string Y { get; set; }
        public string Foo { get; set; }
        public Abc Bar { get; set; }
    }
    public class BlahBlah {
        public BlahBlahXClass[] X { get; set; }
        public SomeLargerType<DefaultGeneric<int>>[] Y { get; set; }
    }
    public class ZZZ {
        public string Z { get; set; }
        public System.Collections.Generic.Dictionary<string, string> V { get; set; }
        public System.Collections.Generic.Dictionary<string, DefaultGeneric<int>> Y { get; set; }
        public System.Collections.Generic.Dictionary<string, SomeGenericType<Abc>> X { get; set; }
    }
    public class Bs<T> : System.Collections.Generic.Dictionary<string, DefaultGeneric<T>> { }
    public enum SomeStupidSubEnum {
        FooBar,
        Baz
    }
    public enum SomeStupidSubEnum2 {
        Fooooo = 2,
        Value2 = 101
    }
    public class DumbType {
        public double Num { get; set; }
        public int Dumber { get; set; }
        public string Un { get; set; }
        public object Absurd { get; set; }
    }
    public class IndexTypeAClass {
        public Abc Foo { get; set; }
    }
    public class IndexType {
        public System.Collections.Generic.Dictionary<string, string> Abc { get; set; }
        public IndexTypeAClass A { get; set; }
    }
    public class GenericIndexType<T> where T: System.Collections.Generic.Dictionary<object, T> {
        public IndexType I { get; set; }
        public T V { get; set; }
    }
    public class AnotherType {
        public string[,,] X { get; set; }
        public int[,,,,] N { get; set; }
    }
    public class GenericArrayType {
        public SomeGenericType<Composite>[] J { get; set; }
        public AnotherType[,] K { get; set; }
    }
    public class GenericArrayType2<V> {
        public V[,] SomeProperty { get; set; }
        public DefaultGeneric<V>[] AnotherProperty { get; set; }
    }
    public class NumbersWithJsDoc {
        /**
        * @type {int}
        */
        public int IntProperty { get; set; }
        /**
        * @type {float}
        */
        public double FloatProperty { get; set; }
    }
    public class ConsumesInterface {
        public int Integer { get; set; }
        public double Float { get; set; }
    }
    public enum TestEnum3 {
        [EnumMember(Value = \\"x\\")]
        X,
        [EnumMember(Value = \\"y\\")]
        Y,
        [EnumMember(Value = \\"z\\")]
        Z
    }
    public class UnionIndex {
        #nullable enable
        public int? A { get; set; }
        public int? B { get; set; }
        public int? C { get; set; }
        #nullable disable
    }
    public class UnionIndex2 {
        public bool A { get; set; }
        public bool B { get; set; }
        public bool C { get; set; }
    }
    public class GenericUnionIndex<T, V> : System.Collections.Generic.Dictionary<T, V> { }
    public class GenericUnionIndex2<T> : System.Collections.Generic.Dictionary<T, string> { }
    public class GenericUnionIndex3<T> : System.Collections.Generic.Dictionary<T, object> { }
    public class GenericUnionIndex4<T> : System.Collections.Generic.Dictionary<T, object> { }
    public class GenericConsumer : System.Collections.Generic.Dictionary<string, int> { }
    // this is a comment that should show up on the GenericConsumerConsumer class
    public class GenericConsumerConsumer {
        // g comment
        public GenericConsumer G { get; set; }
    }
    public class FooBar {
        #nullable enable
        // This property is a function, and it was unable to be translated at this time
        public object? F { get; set; }
        // This property is a function, and it was unable to be translated at this time
        public object? G { get; set; }
        #nullable disable
    }
    public class Whatever1 {
        public object W { get; set; }
    }
    public class RecursiveType {
        public int T { get; set; }
        public RecursiveType R { get; set; }
    }
    public class RecursiveType2 {
        public int T { get; set; }
        public RecursiveType R { get; set; }
    }
    public class RecursiveType3 {
        public int T { get; set; }
        #nullable enable
        public RecursiveType? R2 { get; set; }
        #nullable disable
    }
    public class GenericRecursive {
        public SomeGenericType<object> T { get; set; }
    }
    public enum DumbEnum {
        [EnumMember(Value = \\"member_one\\")]
        MemberOne,
        [EnumMember(Value = \\"member-two\\")]
        MemberTwo,
        [EnumMember(Value = \\"member3\\")]
        Member3,
        [EnumMember(Value = \\"memberMember1\\")]
        MemberMember1,
        [EnumMember(Value = \\"PascalMember\\")]
        PascalMember,
        [EnumMember(Value = \\"application/foooo.a-b-c.x\\")]
        ApplicationFooooABCX
    }
    public class ATuple : System.Tuple<string, int> {
        public ATuple(string Arg0, int Arg1) : base(Arg0, Arg1) { }
 }
    public class BTuple : System.Tuple<double, double, double> {
        public BTuple(double Arg0, double Arg1, double Arg2) : base(Arg0, Arg1, Arg2) { }
 }
    public class CTuple : System.Tuple<string, double, UnionIndex2, object> {
        public CTuple(string Arg0, double Arg1, UnionIndex2 Arg2, object Arg3) : base(Arg0, Arg1, Arg2, Arg3) { }
 }
    public class TupleMap : System.Collections.Generic.Dictionary<string, BTuple> { }
    public class GenericTupleMap<T, U, V> : System.Tuple<T, U, V> {
        public GenericTupleMap(T Arg0, U Arg1, V Arg2) : base(Arg0, Arg1, Arg2) { }
 }
    public class GenericTupleMap2<T, V> : System.Tuple<T, V[]> {
        public GenericTupleMap2(T Arg0, V[] Arg1) : base(Arg0, Arg1) { }
 }
    public class TupleMap2 : System.Tuple<string, string[], int[,,]> {
        public TupleMap2(string Arg0, string[] Arg1, int[,,] Arg2) : base(Arg0, Arg1, Arg2) { }
 }
    public class TupleMap3 : System.Tuple<ATuple[], BTuple[,]> {
        public TupleMap3(ATuple[] Arg0, BTuple[,] Arg1) : base(Arg0, Arg1) { }
 }
    public class Tuple1 : System.Tuple<string, double, SomeGenericType<double>, DefaultGeneric<double>, SomeGenericType<Abc>> {
        public Tuple1(string Arg0, double Arg1, SomeGenericType<double> Arg2, DefaultGeneric<double> Arg3, SomeGenericType<Abc> Arg4) : base(Arg0, Arg1, Arg2, Arg3, Arg4) { }
 }
    public class A {
        public int Foo { get; set; }
    }
    public class B {
        public string Bar { get; set; }
    }
    // Warning: This class might not have been generated correctly. Source to check /Users/imiller/code/personal/csharp-converter/src/test/subfolder/conditional.ts:10
    // Source code:
    // 
    // export type Inverse<T extends A | B> = T extends A ? B : A;
    public class Inverse<T> { }
    public class ConsumesConditional {
        public B Prop1 { get; set; }
    }
    public class ConditionalMappedType<T, V> : System.Collections.Generic.Dictionary<string, object> { }
    public class ConsumesConditionalMappedType {
        public System.Collections.Generic.Dictionary<object, A> X { get; set; }
        public System.Collections.Generic.Dictionary<object, B> Y { get; set; }
    }
}"
`;
